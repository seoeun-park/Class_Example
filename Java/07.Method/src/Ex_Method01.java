public class Ex_Method01 {
	// getSum() 메서드에 10과 20을 매개변수로 보내는 호출문 작성
	public static void main(String[] args) {
		int a = 10, b = 20;		//getSum() 메서드로 보낼 매개변수를 초기화
		getSum(a, b);			//getSum() 메서드 호출문	 ▶  실인수(호출하는 쪽에서 만들어지는 인수)
	}//main()
	
	// 2개의 정수를 매개변수로 받아 합(sum)을 구하여 출력하는 메서드(getSum())를 정의
	public static void getSum(int a, int b) {	//getSum() 메서드를 정의  ▶ 가인수 (정의하면서 만들어지는 인수)
		int sum = a + b;
		System.out.println("첫 번째 인수 : " + a);
		System.out.println("두 번째 인수 : " + b);
		System.out.println("두 인수의 합 : " + sum);
	}//getSum()
	
}//class

/*
 ★  Method(메소드)
 - 객체(클래스)가 가지고 있는 행위 정보를 표현하는 것(동작, 기능) : 함수(Function)
 - 동작(행위)을 만들어 놓고 필요할 때 사용하기 위해서 호출(Calling)
 - 캡슐화의 원칙 : 클래스 안에 메소드를 구현, 하나의 클래스 안에는 여러개의 메소드가 존재

※ 클래스(객체) 안에는 무엇이 들어가는가?
 - main() : 자바는 반드시 main() 메소드에서 프로그램이 실행(동작)	 ▶  Main Class
 - 상태정보 : 멤버 변수(필드)	▶  DTO Class(Data Transform Object), VO Class
 - 행위정보 : 멤버 메소드	▶   DAO Class

★ 메소드의 형식(메소드를 만드는 방법)
  ①		 ②	  	③	 ④			⑤
public static void getSum(int a, int b) {		▶  정의부(프로토타입)
	~ 메소드의 동작 구현 ~								▶  구현부(바디)
  	⑥ return;
}

① 접근 제어자 : public(접근 허용), private(정보은닉 : 내부만 허용), protected, default
② 한정자
  - static(객체를 생성하지 않아도 자동으로 메모리에 생성)	▶  단점 : 메모리를 많이 차지하게 됨
  		    이러한 static의 단점때문에 생략하고 대신 객체를 생성해서 접근한다.
  - final(재정의가 불가 즉, 수정이 불가)
③ 리턴 타입(반환 값) : 메소드가 동작 후에 최종적으로 만들어내는 결과 값의 데이터 타입
  - 리턴을 하지 않는 경우 : void ▶  메소드 내부에 return문이 없다.
  - 리턴을 하는 경우 : 리턴되는 데이터 타입  ▶  메소드 내부에 return문이 있다.
④ 메소드 이름 : 소문자로 시작, 키워드는 사용 불가, 의미있게 작성해야 함   ▶   변수명 작성 규칙과 동일
⑤ 매개변수 리스트 : 메소드가 동작하기 위해서 외부로부터 입력되는 데이터
  	▶  인수, 인자, 매개변수, Parameter
⑥ return문 : 메소드가 동작을 완료한 후, 결과값을 호출한 쪽으로 넘기는 행위

★ 실인수(호출)와 가인수(정의)의 매개변수 전달 규칙 : Parameter Passing Rule
 - 실인수와 가인수의 매개변수의 개수가 같아야 한다.
 - 실인수와 가인수의 매개변수 데이터 타입이 같아야 한다.
 - 실인수와 가인수의 이름은 같아도 되고 달라도 된다.

★ 메소드 오버로딩(시험문제★★★★★★)
  - 클래스 안에 같은 이름을 가지고 있는 메소드
  - 매개변수의 개수가 달라야 한다.
  - 매개변수의 개수가 같을 경우에는 반드시 매개변수의 데이터 타입이 달라야 한다.
  	
 */
